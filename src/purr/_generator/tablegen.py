"""
Emits MLIR TableGen (.td) files from Purr definitions.

This module translates the high-level, Pythonic Purr IR definitions into
the TableGen format that MLIR uses to generate C++ code for operations
and dialects.
"""

from __future__ import annotations

from collections.abc import Sequence

from purr._generator.emitter import CodeEmitter
from purr._internal import builders as _b
from purr._internal import defs as _d
from purr._internal import traits as _t
from purr._internal import types as _ty
from purr._internal.domain import Dialect

PURR_TO_MLIR_ATTR_MAP: dict[type[_ty.IRAttribute], str] = {
    _ty.BoolAttr: "BoolAttr",
    _ty.F64Attr: "F64Attr",
    _ty.I64Attr: "I64Attr",
    _ty.StringAttr: "StrAttr",
    _ty.TypeAttr: "TypeAttr",
    _ty.SymbolRefAttr: "SymbolRefAttr",
}

PURR_TO_MLIR_TYPE_MAP: dict[type[_ty.IRType], str] = {
    _ty.Tensor: "AnyTensor",
    _ty.F32: "F32",
    _ty.F64: "F64",
}

PURR_TO_MLIR_TRAIT_MAP: dict[type[_t.Trait], str] = {
    _t.NoSideEffect: "NoSideEffect",
}


def to_camel_case(snake_str: str) -> str:
    """Converts snake_case to CamelCase."""
    return "".join(word.capitalize() for word in snake_str.split("_"))


class TableGenEmitter:
    """Emits TableGen definitions for a given Purr dialect."""

    def __init__(self, dialect: Dialect, emitter: CodeEmitter | None = None):
        self.dialect = dialect
        self.emitter = emitter or CodeEmitter()

    def emit(self) -> str:
        """Generates the full TableGen string for the dialect."""
        self._emit_header()
        self._emit_dialect_def()
        self._emit_base_op_def()
        for op_def in self.dialect.ops.values():
            self._emit_op_def(op_def)
        return self.emitter.get()

    def _emit_header(self) -> None:
        self.emitter.line(
            "/*===- TableGen'erated file ---------------------------------*- C++ -*-===*\\"
        )
        self.emitter.write(f"|*{' ' * 78}*")
        self.emitter.line(
            "|* Op Definitions                                                             *|"
        )
        self.emitter.write("|* Automatically generated by purr, do not edit! *|")
        self.emitter.write(f"|*{' ' * 78}*")
        self.emitter.line(
            "|*                                                                            *|"
        )
        self.emitter.line(
            "\\*===----------------------------------------------------------------------===*/"
        )
        self.emitter.blank_line()
        self.emitter.line('include "mlir/IR/OpBase.td"')
        self.emitter.blank_line()

    def _emit_dialect_def(self) -> None:
        """Emits the `Dialect` definition."""
        emitter = self.emitter
        dialect = self.dialect
        emitter.line(f"def {dialect.name} : Dialect {{")
        with emitter.indent():
            emitter.line(f'let name = "{dialect.name}";')
            if dialect.description:
                emitter.line(f"let description = [{{ {dialect.description} }}];")
            emitter.line(f'let cppNamespace = "{dialect.cpp_namespace}";')
        emitter.line("}")
        emitter.blank_line()

    def _emit_base_op_def(self) -> None:
        """Emits the base class for all ops in this dialect."""
        emitter = self.emitter
        dialect = self.dialect
        base_name = f"{to_camel_case(dialect.name)}_Op"
        emitter.line(f"class {base_name}<string mnemonic, list<OpTrait> traits = []> :")
        with emitter.indent():
            emitter.line(f"Op<{dialect.name}, mnemonic, traits> {{")
        emitter.line("}")
        emitter.blank_line()

    def _emit_op_def(self, op_def: _d.OpDefinition) -> None:
        emitter = self.emitter
        op_name_camel = to_camel_case(op_def.py_op_name)
        base_name = f"{to_camel_case(self.dialect.name)}_Op"

        traits_str = ""
        if op_def.traits:
            trait_names = [
                PURR_TO_MLIR_TRAIT_MAP[t]
                for t in op_def.traits
                if t in PURR_TO_MLIR_TRAIT_MAP
            ]
            traits_str = f", [{', '.join(trait_names)}]"

        emitter.line(
            f'def {op_name_camel} : {base_name}<"{op_def.py_op_name}"{traits_str}> {{'
        )
        emitter.nl()

        with emitter.indent():
            if op_def.docstring:
                summary = op_def.docstring.strip().split("\\n")[0]
                emitter.line(f'let summary = "{summary}";')
                # TODO: Add full description for multi-line docstrings

            # Arguments (Operands and Attributes)
            self._emit_op_arguments(op_def.operands, op_def.attributes)

            # Results
            self._emit_op_results(op_def.results)

            # Assembly Format
            self._emit_assembly_format(op_def)

        emitter.line("}")
        emitter.blank_line()

    def _emit_op_arguments(
        self,
        operands: Sequence[_d.OperandDef],
        attributes: Sequence[_d.AttributeDef],
    ) -> None:
        emitter = self.emitter
        if not operands and not attributes:
            return

        emitter.write("let arguments = (ins")
        emitter.define_align("arg_type")
        emitter.write(" ")
        emitter.define_align("arg_name")
        emitter.write(" ")
        emitter.define_align("arg_desc")
        emitter.nl()

        with emitter.indent(2):
            emitter.line("Arg<[")

            with emitter.indent():
                # Operands
                for i, op in enumerate(operands):
                    type_str = PURR_TO_MLIR_TYPE_MAP.get(op.ir_type, "AnyType")
                    if op.is_variadic:
                        type_str = f"Variadic<{type_str}>"

                    emitter.write(f"{type_str}:")
                    emitter.align("arg_type")
                    emitter.write(f"${op.name}")
                    if i < len(operands) - 1 or attributes:
                        emitter.write(",")
                    emitter.nl()

                # Attributes
                for i, attr in enumerate(attributes):
                    type_str = PURR_TO_MLIR_ATTR_MAP.get(attr.ir_type, "AnyAttr")
                    if attr.has_default:
                        type_str = (
                            f'DefaultValuedAttr<{type_str}, "{attr.default_value}">'
                        )

                    emitter.write(f"{type_str}:")
                    emitter.align("arg_type")
                    emitter.write(f"${attr.name}")
                    if i < len(attributes) - 1:
                        emitter.write(",")
                    emitter.nl()

            emitter.line("]")
        emitter.line(");")
        emitter.blank_line()

    def _emit_op_results(self, results: Sequence[_d.ResultDef]) -> None:
        emitter = self.emitter
        if not results:
            return

        emitter.write("let results = (outs")
        emitter.define_align("res_type")
        emitter.write(" ")
        emitter.define_align("res_name")
        emitter.nl()

        with emitter.indent(2):
            emitter.line("Arg<[")
            with emitter.indent():
                for i, res in enumerate(results):
                    type_str = PURR_TO_MLIR_TYPE_MAP.get(res.ir_type, "AnyType")
                    if res.is_variadic:
                        type_str = f"Variadic<{type_str}>"

                    emitter.write(f"{type_str}:")
                    emitter.align("res_type")
                    emitter.write(f"${res.name}")
                    if i < len(results) - 1:
                        emitter.write(",")
                    emitter.nl()

            emitter.line("]")
        emitter.line(");")
        emitter.blank_line()

    def _emit_assembly_format(self, op_def: _d.OpDefinition) -> None:
        if op_def.assembly_format is None:
            return

        emitter = self.emitter
        format_parts = []
        has_attr_dict = False
        for directive in op_def.assembly_format:
            if isinstance(directive, _b.AsmKeyword):
                # Escape backticks in keyword values.
                value = directive.value.replace("`", "\\`")
                format_parts.append(f"`{value}`")
            elif isinstance(directive, _b.AsmOperand | _b.AsmAttribute):
                format_parts.append(f"${directive.name}")
            elif isinstance(directive, _b.AsmAttrDict):
                format_parts.append("attr-dict")
                has_attr_dict = True
            elif isinstance(directive, _b.AsmResultType):
                # The functional type is usually handled at the end, outside
                # the main format string, so we just note its presence.
                pass

        # Standard MLIR assembly formats often end with the attribute dictionary
        # (if not explicitly placed), followed by types.
        if not has_attr_dict:
            format_parts.append("attr-dict")

        format_string = " ".join(format_parts)

        # Append the functional type specification.
        # This is a common pattern and provides good diagnostics.
        # `<...>` is for custom directives, which we will not use now.
        format_string += " : functional-type($operands, $results)"

        emitter.line(f'let assemblyFormat = "{format_string}";')
        emitter.blank_line()


def emit_dialect_tablegen(dialect: Dialect) -> str:
    """
    Top-level function to generate a TableGen file for a Purr dialect.
    """
    emitter = TableGenEmitter(dialect)
    return emitter.emit()
